[Módulo - 01] C# y .NET
(001) - ¿Qué es el CLR?
1)El Common Language Runtime o CLR ("entorno en tiempo de ejecución de lenguaje común"). Entorno en donde trabajamos y donde se ejecutan los códigos .NET

(002) - Describa el proceso de compilación de C#.
2)En tiempo de compilación pasa el lenguaje C# a lenguaje intermedio, en tiempo de ejecución pasa el intermedio a máquina.

(003) - ¿Qué es el CTS?
3)Common Type System determina cómo están representados los tipos, sus usos y cómo se manejan dentro del CLR

(004) - ¿Qué es un tipo por referencia (Reference Type)? ¿En qué se diferencia de un
tipo por valor (Value Type)?
4)Referencia guarda la direccion de memoria hacia el objeto que refiere. En cambio, valor contiene esos datos directamente.

(005) - Explique las diferencias entre variables escalares y no escalares.
Las escalares son constantes o variables que contienen un único dato. Ej: int. Las no escalares pueden contener más de un dato. Ej: listas.

(006) - ¿Cuál es el punto de entrada (entry point) para los programas en C#?
El método Main.

(007) - ¿Cuál es la diferencia entre una conversión implícita y una explícita?
En la implícita no interviene el programador y en explicita se hace a través de casteo y puede haber pérdida de datos.


[Módulo - 02] Programación orientada a objetos
(008) - ¿Qué propone el paradigma orientado a objetos? ¿Qué es un paradigma?
8)Facilita la forma de conseguir resultados mediante objetos con funciones especiales que manejan los datos de entrada para obtener ciertos datos de salida.

(009) - Nombre a los pilares del paradigma orientado a objetos.
9)Abstracción, herencia, polimorfismo y encapsulamiento.

(010) - ¿Qué es una clase?
10)Plantilla que nos permite crear objetos, que puede tener atributos, propiedades y métodos.

(011) - ¿Qué es un objeto? ¿En qué se relacionan con las clases?
11)Es una instancia de una clase que poseen atributos, propiedades y métodos.

(012) - ¿Qué significa instanciar un objeto?
12)Se asigna espacio en memoria a un objeto, no se instancia un objeto se inicializa.

(013) - Explique qué es la abstracción en el contexto de programación orientada a
objetos y cuál es su relación con las clases.
13)Omitir detalles innecesarios de la realidad a la hora de crear objetos dándoles atributos y metodos.

(014) - ¿Qué son los atributos o estado de un objeto?
14)Características diversas de ese objeto.

(015) - ¿Qué son los métodos de un objeto?
15)Comportamientos o acciones tras la recepción de un llamado.

[Módulo - 03] Miembros estáticos y de instancia:
(016) - ¿Qué es un método estático? ¿En qué se diferencia de los métodos de
instancia (no estáticos)?
16)Un método estático se crea independientemente a la definición de un objeto, en cambio en los de instancia precisamos de la instanciacion de un objeto.

(017) - ¿Qué es una clase estática? ¿En qué se diferencia de las clases no estáticas?
17)Es una clase que se puede usar sin una instanciación de la misma y que no se pueden crear objetos de ella. Tampoco pueden implementar interfaces.

(018) - ¿Puedo tener miembros estáticos en clases no-estáticas? ¿Puedo tener
miembros no-estáticos en clases estáticas?
18)Sí. No

(019) - ¿Necesito instanciar un objeto de la clase para llamar a sus métodos estáticos?
19)No porque no se pueden instanciar.

(020) - ¿Cuántos valores distintos pueden existir para un campo estático y cuántos de
uno no-estático cuando se crearon 5 instancias de la clase?
20)En un campo estático solo uno porque es constante y en uno no estático cinco.

(021) - ¿Se puede usar el operador “this” dentro de un método estático? ¿Se puede
acceder a miembros no-estáticos desde un método estático de la misma clase? ¿Se
puede acceder a miembros estáticos desde un método de instancia?
21)No, porque se puede llamar sin instanciar. Un método estatico no puede acceder a los atributos salvo que sean estaticos, pero uno de instancia si puede acceder a miemnbros estaticos.

(022) - ¿Se pueden declarar variables estáticas dentro de un método (locales)?
22)No, porque se inicializan solo una vez al inicio de la ejecución

(023) - De dos ejemplos de métodos estáticos que pertenezcan a las clases de .NET
Framework.
23)Math.Pow y Console.WriteLine

(024) - De un ejemplo de un método de instancia que pertenezca a las clases de .NET
Framework.
24)Next de la clase Random

[Módulo - 04] Namespaces y directivas:
(025) - ¿Qué es un namespace y cuál es su función principal?
25)Es un espacio cuya alcance contiene un grupo de objetos relacionados. Se usa para organizar codigo o para manejar mas facilmente el programa.

(026) - ¿Puedo tener distintos namespaces dentro de un mismo proyecto o
ensamblado de .NET?
26)Es posible, pero no se recomienda para que no haya equivocaciones

(027) - ¿Para qué se usa la directiva using?
27)Permite la llamada a un metodo sin el uso obligatorio de un nombre cualificado

(028) - ¿Para qué se usa la directiva alias?
28)Permite utilizar un nombre distinto para un namespace

(029) - ¿Puedo declarar dos clases independientes/distintas con el mismo
identificador dentro del mismo namespace? ¿Y en namespaces distintos?
29)No en el mismo si en distintos.



[Módulo - 05] Objetos:
(030) - ¿Los objetos se crean en tiempo de diseño, de compilación o de ejecución?
30)Se crean en tiempo de ejecución

(031) - ¿Cuántos objetos de tipo Alumno puedo tener en mi sistema? ¿Cuántas clases
Alumno tengo en mi sistema? (Dentro de un mismo namespace).
31)Infinitos objetos, pero solo una clase.

(032) - Explique el ciclo de vida de un objeto. Detalle las funciones del operador new,
del constructor y del Garbage Collector.
32)Creacion del objeto, reserva de memoria para el objeto con el operador new, inicializacion con el constructor y destrucción con el Garbage Collector

(033) - ¿En qué segmento de memoria se almacenan los tipos valor (value type) y en
cuál los tipos por referencia (reference type)? ¿En cuál interfiere al Garbage
Collector?
33)Valor en stack y referencia en heap. El Garbage interfiere en el heap.

(034) - Compare y describa: Destrucción determinista y no determinista. Asocie con
el concepto de variables y objetos.
34)La determinista es cuando algo se crea al momento de declararse y se destruye al final del mismo ámbito, en cambio la no determinista aparece cuando se crea pero no se destruye al final de cierto ambito

(035) - ¿Cuál es la diferencia entre declarar, inicializar e instanciar un objeto?
35)Declarar es dar una referencia de una clase pero con valor null. Inicializar significa darle algún tipo de valor distinto de null. Instanciar es invocar al constructor.


[Módulo - 06] Constantes:
(036) - ¿Qué es una constante? ¿Se puede declarar constantes estáticas (static const)?
36)Una constante es un valor que no cambiará con el paso del tiempo. Al ser implicitamente estatica, c# no permite redundancias.

(037) - ¿Cuándo se asigna el valor a las constantes (tiempo de compilación o
ejecución)? ¿Dos objetos del mismo tipo pueden tener distintos valores en una
misma constante? Relacione con atributos de instancia y estáticos.
37)Se le asigna en tiempo de compilación. No se puede porque las constantes no cambian de valor.



[Módulo - 07] Constructores:
(038) - ¿Qué es un constructor? ¿Cuál es su función?
38)Un metodo que permite inicializar un objeto al momento de su creacion. 

(039) - ¿Qué es el constructor por defecto? ¿Qué sucede con el mismo cuando
declaramos un constructor nuevo en la clase?
39)Crea una instancia y establece las variables miembro en sus respectivos valores predeterminados y el mismo dejará de tener validez cuando se cree alguno con parametros.

(040) - ¿Con qué valores se cargan los atributos cuando se llama al constructor por
defecto?
40)False, Null y 0

(041) - ¿Qué es y para qué sirve un constructor estático? ¿En qué se diferencia su
sintaxis de los constructores de instancia?
41)Un constructor sin parametros que se usa para inicializar datos estaticos o para realizar acciones que se hagan una unica vez

(042) - ¿Cuántas veces se puede llamar a un constructor estático? ¿Quién lo puede
llamar?
42)Se puede llamar una sola vez y se invoca automaticamente por el CLR para inicializar la clase antes de la primera instancia

(043) - ¿Se ejecutará primero un constructor estático o uno de instancia?
43)Uno estatico


[Módulo - 08] Sobrecargas (Overload):
(044) - ¿Qué significa sobrecargar un método o constructor?
44)Recrearlo para darle nueva funcionalidad con otros parametros

(045) - ¿Qué debe cambiar para que la sobrecarga de un método o constructor sea
válida?
45)Los parametros (orden y tipo)

(046) - ¿La sobrecarga se resuelve en tiempo de ejecución o en tiempo de
compilación? ¿Cómo se distingue a qué sobrecarga llamar?
46)Tiempo de compilacion cuando es static o tiempo de ejecucion con la dinamica del polimorfismo. Se distingue por las diferentes firmas que muestra Intellisense a la hroa de escribir

(047) - ¿Se tiene en cuenta el nombre o identificador de los parámetros de entrada
para una sobrecarga?
47)No

(048) - ¿Se tiene en cuenta el modificador de visibilidad para una sobrecarga?
48)No


[Módulo - 09] Sobrecarga de métodos:
(049) - ¿Los métodos pueden tener el mismo nombre que otros elementos de una
misma clase? (atributos, propiedades, etc).
49)No

(050) - Mencione dos razones por las cuales se sobrecargan los métodos.
50)Añadir funcionalidad al codigo y metodos similares que requieran parametros distintos

(051) - ¿Los métodos estáticos pueden ser sobrecargados?
51)Sí

(052) - ¿Agregar el modificador “static” sin cambiar los parámetros de entrada es una
sobrecarga válida?
52)No

(053) - ¿Agregar un modificador “out” o “ref” en la firma del método sin cambiar nada
más es una sobrecarga válida?
53)Sí

(054) - ¿Cambiar el tipo de retorno sin cambiar los parámetros de entrada es una
sobrecarga válida?
54)No

(055) - Si tenemos distintas sobrecargas de un método, ¿cómo podemos reutilizar
código?
55)Se puede reutilizar al usar instancias o llamando metodos



[Módulo - 10] Sobrecarga de constructores:
(056) - ¿Para qué se utiliza el operador “this()”?
56)Permite llamar a un constructor con una firma diferente dentro de la misma clase.

(057) - ¿Se pueden sobrecargar los constructores estáticos?
57)No

(058) - ¿Se puede llamar a un constructor estático con el operador “this()”?
58)No

(059) - ¿Se puede llamar a constructores de otras clases con el operador “this()”?
59)No

(060) - ¿Se puede sobrecargar un constructor privado?
60)Sí



[Módulo - 11] Sobrecarga de operadores:
(061) - ¿Qué es un operador? ¿En qué se diferencian un operador unario y un
operador binario? De un ejemplo de cada uno.
61)Un elemento que se aplica a uno o mas operandos en una instruccion. La cantidad de operandos que aplican define si son unarios (++) o binarios (%)

(062) - ¿Qué varía en la sintaxis de la sobrecarga de operadores unarios y binarios?
62)La cantidad de parametros en cada una de las sobrecargas

(063) - ¿Se pueden sobrecargar los operadores de operación y asignación (+=, -=, *=,
/=)? ¿Por qué?
63)No, porque ya se sobrecargan de manera unaria (+, -, * y /)

(064) - ¿Cuál es la diferencia entre un operador de conversión implícito y uno
explícito? (En finalidad, declaración y aplicación)
64)En la firma cambian explicit e implicit, en aplicacion puede haber perdida de datos en el explicito y en la finalidad se requiere casteo a la hora del explicito

(065) - Los operadores de casteo “(T)x” no se pueden sobrecargar. ¿Cuál es la
alternativa?
65)Crear un metodo que convierta explicitamente un tipo en otro

(066) - ¿Cuál es la diferencia entre castear (casting), convertir (converting) y parsear
(parsing)?
66)Castear es cambiar el tipo de una variable por otro sin cambiar su valor. Convert significa transformar el valor de una variable por otro. Parsing solo se aplica cuando se convierte un string en otro tipo



[Módulo - 12] Formularios:
(067) - ¿Los formularios son objetos?
Si.

(068) - ¿De qué clase heredan todos los formularios?
De la clase Form.

(069) - ¿Qué es una partial class o clase parcial?
El lenguaje C# permite la implementación de una clase en dos o más archivos. ... 
Una clase parcial no es más ni menos que crear una clase completa y luego agrupar métodos y propiedades 
en dos o más archivos.

(070) - ¿Puedo agregar parámetros de entrada a la clase del formulario? ¿Y
sobrecargar el constructor? ¿Y declarar nuevos campos/propiedades?
Si, si si.

(071) - ¿Cuál es la diferencia entre Show() y ShowDialog()?
La diferencia es que el ShowDialog() muestra un form modal, o sea muestra el form y hasta 
que no lo cierras no podras acceder a los inferiores
el Show() abre un form pero no bloquea al resto, puede abrir varios formulario y acceder a uno u otro indistintamente.

(072) - ¿Qué es un formulario MDI? ¿Con qué propiedad indico que un formulario es
un contenedor MDI? ¿Con qué propiedad del formulario hijo indico cuál es el
formulario MDI padre?
Un formulario MDI es un formulario (llamado "Padre" o "Parent") que puede contener otros formularios (llamados "Hijos" o "Child"). De forma automàtica se crea un formulario con nombre "Form1". En la ventana Propiedades, se busca la propiedad "IsMDIContainer" y se cambia a "True". 
Luego en el menú se elige Proyectos -> Agregar Windows Form. Aparecerá la ventana de "Agregar Nuevo Elemento". Se elige "Windows Form".

(073) - Explique el ciclo de vida de los formularios asociándolo a sus eventos
correspondientes.
New instsncia el formulario. Load lo pone en memoria, pero invisible. Paint dibuja el formulario y sus controles. Activated el formulario recibe el foco. FormClosing permite cancelar el cierre. FormClosed el formulario ya es invisible. Disposed el objeto es destruido.


[Módulo - 13] Arrays:
(074) - ¿Qué es un array “jagged”? ¿En qué valor se inicializan sus elementos?
Es un array de arrays. Valor de inicializacion null.

(075) - ¿Los arrays son objetos?
Si.

(076) - ¿Qué significa que en C# los arrays son de “base-cero”?
Que el primer elemento agregado se inicializa en la posicion 0 del array.

(077) - Los arrays implementan la interfaz IEnumerable, ¿qué es lo que esto les
permite hacer?
Permite usar foreach para recorrer el array

(078) - ¿Cómo se declara e instancia un array multidimensional?
  int[,] multiDimensionalArray1 = new int[2, 3]; Segun la cantidad de dimensiones, van cantidad de comas(??

(079) - Considerando que la propiedad Length devuelve la cantidad TOTAL de
elementos de TODAS las dimensiones del array, ¿qué valor vamos a mostrar por
consola en el siguiente código?:

a. int[ , , ] a = new int[ 3, 2, 3 ];

int[ , ] b = new int[ 5, 4 ];

Console.WriteLine(“Array Length = {0}”, a.Length + b.Length);

La respuesta es 38



[Módulo - 14] Strings:
(080) - ¿Es lo mismo declarar una variable como string (en minúscula) o como String
(con la primera letra en mayúscula)? ¿Por qué?
Si, porque string deriva de String, es un alias.

(081) - ¿Se puede recorrer un string con un foreach? ¿Por qué?
Si, porque un string es una cadena de caracteres y cada letra tiene una "posicion", se puede haciendo foreach char c in nombredelstring

(082) - ¿Qué significa que los strings son inmutables? ¿qué sucede en realidad cuando
usamos métodos u operadores para modificar un string?
Que no se pueden modificar una vez creados. Cuando usamos metodos u operadores para modificar un string en realidad lo que se hace es crear un string nuevo con el mismo
nombre de la variable con la modificacion y la referencia al anterior string se pierde referencia por lo tanto sera recogido por el garbage collector.




[Módulo - 15] Colecciones:
(083) - ¿Cuál es la diferencia entre las colecciones y las matrices?
A diferencia de las matrices, el grupo de objetos con el que trabaja puede aumentar y reducirse dinámicamente 
a medida que cambian las necesidades de la aplicación.

(084) - ¿Cuál es la diferencia entre las colecciones genéricas y las no genéricas?
Una colección genérica cumple la seguridad de tipos para que ningún otro tipo de datos se pueda agregar a ella. Una no generica no.

(085) - ¿Es necesario determinar el tipo de dato o realizar una conversión al recuperar
un objeto de una colección genérica?
Cuando se recupera un elemento de una colección genérica, no tiene que determinar su tipo de datos ni convertirlo.

(086) - Describa los siguientes tipos de colecciones genéricas: Dictionary, List,
SortedList.
Dictionary:
Representa una colección de pares de clave y valor que se organizan por claves.
List:
Representa una lista de objetos que pueden ser obtenidos mediante un índice.
SortedList:
Representa una colección de pares de clave y valor que se ordenan por claves según la implementación de la interfaz IComparer<T> asociada.


(087) - ¿Qué son y cuál es la diferencia entre una cola (queue) y una pila (stack)?
Asocie con los conceptos “FIFO” y “LIFO”.
Stack:
Representa una colección de objetos con el orden último en entrar, primero en salir (LIFO).
Queue:
Representa una colección de objetos con el orden primero en entrar, primero en salir (FIFO).

(088) - Describa los siguientes tipos de colecciones no genéricas: ArrayList, Hashtable.
Hashtable
Representa una colección de pares de clave y valor que se organizan por código hash de la clave.
ArrayList
Representa una matriz de objetos cuyo tamaño aumenta dinámicamente según sea necesario.


(089) - ¿Se pueden ordenar directamente las colas y las pilas? ¿Por qué (piense en la
función de dichas colecciones)? ¿Cuál es la alternativa?
Las pilas y las colas no se pueden ordenar, en todo caso se puede crear una lista con los valores que esten en la cola/pila y despues esta lista
ordenarla y recien ahi convertirla en una cola o pila nueva.

(090) - ¿Cuál es la diferencia entre las colas y pilas genéricas y las colas y pilas no
genéricas?
Las genericas almacenan lo recibido como el tipo de dato al que pertenecen y las no genericas almacenan todo como si fuese objetos.

(091) - ¿Qué muestra el siguiente código?

a. 1, 2, 3, 4, 5,
b. 5, 4, 3, 2, 1,
c. 8, 6, 4, 2, 0, ---
d. 0, 2, 4, 6, 8,
e. 1, 3, 5, 7, 9,
f. 9, 7, 5, 3, 1,
g. Error en tiempo de ejecución. Marcar error.
h. Error en tiempo de diseño. Marcar error.



[Módulo - 16] Propiedades:
(092) - ¿Qué es y para qué sirve una propiedad?
(093) - ¿Para qué sirve el descriptor de acceso “get”?
devolver el valor
(094) - ¿Para qué sirve el descriptor de acceso “set”? ¿Cuál es el papel de la palabra
clave “value”?
setea datos y value hace referencia al atributo 
(095) - ¿Cómo declaro una propiedad de sólo lectura?
solo get
(096) - ¿Cómo declaro una propiedad de sólo escritura?
solo set



[Módulo - 17] Enumerados:
(097) - ¿Qué es un enumerado? ¿Cuál es su función?
(098) - ¿Un enumerado sólo puede estar anidado dentro de una clase?
no
(099) - ¿Cuál es el primer valor numérico de un enumerado por defecto? ¿Se pueden
sobrescribir los valores por defecto?
valor por defecto 0. Se puede sobreeescribir
(100) - Indique los valores asociados a cada constante:
enum Day {Sat0, Sun1, Mon=15, Tue16, Wed17, Thu=2, Fri3};



[Módulo - 18] Indexadores:
(101) - ¿Qué significa indexar?
registrar ordenamiento segun un criterio
(102) - ¿Qué permite un indexador (función)?
permiten a un objeto ser indexado como un array
(103) - ¿Cuál es la diferencia a la hora de declarar un indexador y una propiedad?
recibe parametros y utiliza this para su definicion
(104) - ¿Los indexadores solo se pueden indexar por valores numéricos?
No es necesario
(105) - ¿Un indexador puede recibir más de un parámetro (ser multidimensionales)?

(106) - ¿Los indexadores pueden ser sobrecargados?
(107) - ¿Cuál es el papel de la palabra clave “this” en un indexador?
(108) - ¿Cuál es el papel de la palabra clave “value” en un indexador?
(109) - ¿Se pueden declarar indexadores estáticos? ¿Por qué?
no

[Módulo - 19] Encapsulamiento:
(110) - Defina encapsulamiento / encapsulación en el contexto del paradigma
orientado a objetos.
(111) - Defina cada nivel de ocultamiento / accesibilidad de la programación
orientada a objetos. Incluya la función del modificador “internal” en C#.
public
private
protected
internal
private protected
protected internal


[Módulo - 20] Herencia:
(112) - ¿Qué es la herencia en el contexto de la programación orientada a objetos?
¿Cuál es su propósito?
(113) - ¿Qué nombre recibe la clase que hereda y qué nombre recibe la clase que es
heredada?
(114) - ¿Qué significa que la herencia es transitiva?
(115) - ¿Se heredan los constructores?
no
(116) - ¿Se heredan los miembros private de la clase base?
si
(117) - ¿Qué es herencia múltiple? ¿Es posible en C#? ¿En qué se diferencia de la
herencia simple?
no
(118) - ¿Una clase pública puede heredar de una clase privada?
NOOOOOOOOOOOOOOOO
(119) - ¿Qué es una clase sellada (sealed)?
una clase que no puede tener herencias
(120) - ¿Una clase sellada puede heredar de otras clases? (Ser clase derivada)
si
(121) - ¿Cómo actúa el modificador “protected” en los miembros de la clase base para
una clase derivada y cómo para una clase no-derivada? Relacionar la respuesta con
los modificadores “public” y “private”.
(122) - ¿Qué pasa si la clase derivada no hace una llamada explícita a un constructor
de la clase base? En esta situación, ¿qué pasa si la clase base declaró explícitamente
un constructor con parámetros de entrada?
tira error porque no permite no hacer uso de los atributos heredados



[Módulo - 21] Polimorfismo:
(123) - ¿Qué es el polimorfismo en el contexto de la programación orientada a
objetos?

(124) - ¿Qué implica el polimorfismo basado en herencia?
cuando tengo una clase base puede suplantar a las heredadas


[Módulo - 22] Sobreescritura de métodos (Override):
(125) - ¿Dónde reside la definición del método a sobrescribir? ¿Qué palabra clave se
usa para definirlo?
En la clase base. Virtual
(126) - ¿Dónde reside la implementación del método a sobrescribir? ¿Qué palabra
clave se usa para implementarlo?
En la clase derivada. Override
(127) - ¿Cuándo se resuelve la invocación? (Tiempo de ejecución o compilación)
tiempo de ejecucion
(128) - ¿Cuáles son las diferencias entre sobrecargar (overload) y sobrescribir
(override) un método? (Llenar la tabla)

Criterio                                              Sobrecargar/Overload     Sobrescribir/Override
Firma (Diferencias o no diferencias en las firmas)    distintas			iguales
Ubicación (Misma clase / Clases diferentes)           iguales			distintas
Tiempo de resolución (Compilación / Ejecución)        compilacion		ejecucion
Tipo objeto / Tipo Referencia (¿Qué determina         referencia		objeto
cuál implementación se utilizará?)



[Módulo - 23] Clases y miembros abstractos:
(129) - Si quiero declarar un método que pueda ser sobrescrito en las clases derivadas,
¿qué modificador debo usar?
Se utiliza el modificador virtual.

(130) - Si quiero declarar un método que deba ser sobrescrito en las clases derivadas,
¿qué modificador debo usar?
Se utiliza el modificador abstract.


(131) - ¿Qué es una clase abstracta? ¿Cuál es su función?
no se puede instanciar
(132) - Las clases no-abstractas que derivan de una clase abstracta, ¿deben
implementar todos sus métodos abstractos?
si
(133) - Las clases abstractas que derivan de una clase abstracta, ¿deben implementar
todos sus métodos abstractos?
no
(134) - ¿Se pueden declarar miembros abstractos en clases no-abstractas?
no
(135) - ¿Para sobrescribir un método se debe heredar de una clase abstracta?
si
(136) - Llenar los campos de la siguiente tabla con SÍ o NO según corresponda.
Tipo de Clase 	Puede heredar de 
		otras clases (ser
		derivada)
Puede heredarse
de ella (ser base)
Puede ser
instanciada
normal (sin
modificadores)
abstract
sealed
static
